
import { Accessor, MemoOptions, getOwner, createRoot, createMemo, onCleanup, Owner } from "solid-js";

/** Type of the error thrown when an {@link Accessor} generated by {@link createUnownedMemo} tries to read itself */
export class CircularMemoError extends Error { }

/**
 * A collection of symbols that each represents an internal of an object.
 * They're used to track/notify changes to those internals
 */
export namespace Internal {
    export const IS_EXTENSIBLE = Symbol("[[IsExtensible]]");
    export const PROTO = Symbol("[[Prototype]]");
    export const SHAPE = Symbol("[[Shape]]");
}

/**
 * Makes an instance function static.
 * It creates a function that behaves like {@link Function.call} of {@link f}.
 * Example:
 * ```js
 * f.call(a, b);
 * staticCall(f)(a, b);
 * ```
 * @param f The function to make static
 */
export const staticCall = <T, Args extends readonly unknown[], R>(f: (this: T, ...args: Args) => R) => Function.prototype.call.bind(f) as (x: T, ...args: Args) => R;

/**
 * Gets the eventual getter of a property across the prototype chain using the fast deprecated method {@link Object.prototype.__lookupGetter__}
 * @param obj Object from which to get the getter
 * @param k Key of the property that may have a getter
 */
export const getGetter = staticCall((<any>Object.prototype).__lookupGetter__ as <T, K extends keyof T>(this: T, k: K) => { (): T[K] } | undefined);

/**
 * Like {@link createMemo}, but doesn't need an {@link Owner}.
 * The memo is disposed without the need of an {@link Owner} by delegating its disposal to the {@link Owner}s that read it.
 * The memoization happens only if the result has been read from at least one {@link Owner} that is currently active.
 * The resulting {@link Accessor} throws a {@link CircularMemoError} if it's read by itself while it's being memoized, this is to avoid creating the memo when it's already being created.
 * It doesn't throw if you simply read the result when the memo already exists or it's not needed, this is because **"solid-js"** will sometimes call the {@link Accessor} from whithin itself when it's already memoized (In this cases it will observe that the memo does't need to be updated thus not executing its contents).
 * For more informations, check [this](https://github.com/solidjs/solid/discussions/2489) discussion
 * @param f The function to memoize
 * @param opts The options to pass down to {@link createMemo}
 */
export function createUnownedMemo<T>(f: Accessor<T>, opts?: MemoOptions<T>): Accessor<T> {
    var count = 0, disp: (() => void) | undefined, memo: Accessor<T> | undefined | null;
    return () => {
        if (memo === null) throw new CircularMemoError("The memo is being read by itself while it's being memoized");
        if (!getOwner()) return (memo ? memo : f)();
        if (!memo) {
            memo = null;
            try { [ disp, memo ] = createRoot(d => [ d, createMemo(f, undefined, opts) ]); }
            catch (err) { throw memo = undefined, err; }
        }
        count++;
        onCleanup(() => --count || (disp!(), memo = disp = undefined));
        return memo();
    };
}